#!/usr/bin/env python
"""
FastAPI web application for the personal AI assistant.
Provides REST endpoints and WebSocket connections for interacting with the agent.
"""
import os
import json
import logging
import asyncio
import datetime
import uuid
from typing import Dict, List, Optional, Any, Union

import uvicorn
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from dotenv import load_dotenv

# Import the agent implementation
from agent import Agent, AgentCalendarAssistant

# Load environment variables
load_dotenv()

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("api.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("api")

# Create FastAPI app
app = FastAPI(
    title="AI Calendar Assistant API",
    description="API for interacting with the AI Calendar Assistant",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ----- Pydantic Models for Request/Response -----

class MessageRequest(BaseModel):
    """Request model for sending a message to the agent."""
    message: str = Field(..., description="The message to send to the agent")
    session_id: Optional[str] = Field(None, description="Session ID for maintaining conversation state")

class MessageResponse(BaseModel):
    """Response model from the agent."""
    response: str = Field(..., description="The agent's response")
    session_id: str = Field(..., description="Session ID for maintaining conversation state")
    
class ChatMessage(BaseModel):
    """Model for chat messages in WebSocket communication."""
    content: str = Field(..., description="Message content")
    role: str = Field("user", description="Message role (user or assistant)")
    timestamp: Optional[str] = Field(None, description="Message timestamp")
    message_id: Optional[str] = Field(None, description="Unique message identifier")
    
class ChatResponse(BaseModel):
    """Model for responses in WebSocket communication."""
    type: str = Field(..., description="Response type (message, error, typing, system)")
    content: Any = Field(..., description="Response content")
    message_id: Optional[str] = Field(None, description="Message ID for tracking")

class SessionState(BaseModel):
    """Model for tracking session state."""
    session_id: str
    created_at: str
    last_active: str
    message_count: int = 0
    user_info: Optional[Dict] = None
    
class CalendarEventRequest(BaseModel):
    """Request model for creating a calendar event."""
    summary: str = Field(..., description="Event summary/title")
    start_time: str = Field(..., description="Event start time (ISO format)")
    end_time: str = Field(..., description="Event end time (ISO format)")
    description: Optional[str] = Field(None, description="Event description")
    location: Optional[str] = Field(None, description="Event location")
    calendar_id: Optional[str] = Field("primary", description="Calendar ID")

class TaskRequest(BaseModel):
    """Request model for creating a task."""
    title: str = Field(..., description="Task title")
    notes: Optional[str] = Field(None, description="Task notes/description")
    due_date: Optional[str] = Field(None, description="Due date (ISO format)")
    tasklist_id: Optional[str] = Field(None, description="Task list ID")

# ----- Agent Connection Manager -----

class ConnectionManager:
    """Manages WebSocket connections and agent instances."""
    
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.agent_instances: Dict[str, Agent] = {}
        self.session_states: Dict[str, SessionState] = {}
        self.typing_tasks: Dict[str, asyncio.Task] = {}
    
    async def connect(self, websocket: WebSocket, session_id: str):
        """Connect a client and create an agent instance if needed."""
        await websocket.accept()
        self.active_connections[session_id] = websocket
        
        # Create or update session state
        current_time = datetime.datetime.now().isoformat()
        if session_id not in self.session_states:
            # Create new session state
            self.session_states[session_id] = SessionState(
                session_id=session_id,
                created_at=current_time,
                last_active=current_time
            )
        else:
            # Update existing session state
            self.session_states[session_id].last_active = current_time
            
        # Create agent instance if it doesn't exist
        if session_id not in self.agent_instances:
            try:
                # Check if credentials file exists first
                if not os.path.exists('credentials.json'):
                    await self.send_message(session_id, {
                        "type": "error",
                        "content": "Missing credentials.json file. Please set up OAuth credentials."
                    })
                    return False
                
                # Create agent instance
                self.agent_instances[session_id] = AgentCalendarAssistant()
                await self.send_message(session_id, {
                    "type": "system",
                    "content": "Agent initialized successfully",
                    "metadata": {
                        "session_info": self.session_states[session_id].dict()
                    }
                })
                return True
            except Exception as e:
                logger.error(f"Error initializing agent: {e}")
                await self.send_message(session_id, {
                    "type": "error",
                    "content": f"Failed to initialize agent: {str(e)}"
                })
                return False
        else:
            await self.send_message(session_id, {
                "type": "system",
                "content": "Reconnected to existing session",
                "metadata": {
                    "session_info": self.session_states[session_id].dict()
                }
            })
        return True
                
    def disconnect(self, session_id: str):
        """Disconnect a client and clean up."""
        if session_id in self.active_connections:
            del self.active_connections[session_id]
            
        # Cancel any pending typing indicator task
        if session_id in self.typing_tasks and not self.typing_tasks[session_id].done():
            self.typing_tasks[session_id].cancel()
            del self.typing_tasks[session_id]
        
    def get_agent(self, session_id: str) -> Optional[Agent]:
        """Get the agent instance for a session."""
        return self.agent_instances.get(session_id)
    
    async def send_message(self, session_id: str, data: Dict):
        """Send a message to a specific session."""
        if session_id in self.active_connections:
            await self.active_connections[session_id].send_json(data)
    
    async def send_typing_indicator(self, session_id: str, duration: int = 2):
        """Send a typing indicator to the client that lasts for the specified duration."""
        if session_id in self.active_connections:
            # Start typing
            await self.send_message(session_id, {"type": "typing", "content": True})
            
            try:
                # Wait for the specified duration
                await asyncio.sleep(duration)
            finally:
                # Stop typing (even if canceled)
                if session_id in self.active_connections:
                    await self.send_message(session_id, {"type": "typing", "content": False})
    
    def start_typing_indicator(self, session_id: str, duration: int = 2):
        """Start a typing indicator as a background task."""
        if session_id in self.typing_tasks and not self.typing_tasks[session_id].done():
            self.typing_tasks[session_id].cancel()
            
        self.typing_tasks[session_id] = asyncio.create_task(
            self.send_typing_indicator(session_id, duration)
        )
        
    def update_session_state(self, session_id: str, increment_message_count: bool = True):
        """Update the session state's last active time and message count."""
        if session_id in self.session_states:
            self.session_states[session_id].last_active = datetime.datetime.now().isoformat()
            if increment_message_count:
                self.session_states[session_id].message_count += 1

# Create a connection manager instance
manager = ConnectionManager()

# ----- REST Endpoints -----

@app.get("/")
async def root():
    """Root endpoint to verify the API is running."""
    return {
        "status": "ok", 
        "message": "AI Calendar Assistant API is running",
        "version": "1.0.0",
        "docs_url": "/docs",
        "endpoints": {
            "chat": "/chat",
            "websocket": "/ws/{session_id}",
            "calendars": "/calendars",
            "events": "/events",
            "tasks": "/tasks"
        }
    }

@app.post("/chat", response_model=MessageResponse)
async def chat(request: MessageRequest):
    """Process a chat message and return the agent's response."""
    session_id = request.session_id or "default"
    
    # Get or create agent instance
    agent = manager.get_agent(session_id)
    if not agent:
        try:
            agent = AgentCalendarAssistant()
            manager.agent_instances[session_id] = agent
        except Exception as e:
            logger.error(f"Error initializing agent: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to initialize agent: {str(e)}"
            )
    
    # Process the message
    try:
        response = agent.process_input(request.message)
        return MessageResponse(
            response=response,
            session_id=session_id
        )
    except Exception as e:
        logger.error(f"Error processing message: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing message: {str(e)}"
        )

@app.get("/calendars")
async def list_calendars(session_id: str = "default"):
    """List available calendars."""
    agent = manager.get_agent(session_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    try:
        calendars = agent.calendar.available_calendars
        return {"calendars": calendars}
    except Exception as e:
        logger.error(f"Error listing calendars: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing calendars: {str(e)}"
        )

@app.post("/events")
async def create_event(event: CalendarEventRequest, session_id: str = "default"):
    """Create a calendar event."""
    agent = manager.get_agent(session_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    try:
        result = agent.calendar.create_event(
            summary=event.summary,
            start_time=event.start_time,
            end_time=event.end_time,
            description=event.description,
            location=event.location,
            calendar_id=event.calendar_id
        )
        return {"event": result}
    except Exception as e:
        logger.error(f"Error creating event: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating event: {str(e)}"
        )

@app.get("/events")
async def list_events(
    calendar_id: str = "primary", 
    max_results: int = 10, 
    time_min: Optional[str] = None,
    time_max: Optional[str] = None,
    session_id: str = "default"
):
    """List calendar events."""
    agent = manager.get_agent(session_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    try:
        events = agent.calendar.list_events(
            max_results=max_results,
            time_min=time_min,
            time_max=time_max
        )
        return {"events": events}
    except Exception as e:
        logger.error(f"Error listing events: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing events: {str(e)}"
        )

@app.get("/tasks")
async def list_tasks(tasklist_id: Optional[str] = None, session_id: str = "default"):
    """List tasks from a task list."""
    agent = manager.get_agent(session_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    try:
        # If no tasklist specified, get the default one
        if not tasklist_id:
            tasklists = agent.tasks.list_tasklists()
            if not tasklists:
                return {"tasks": []}
            tasklist_id = tasklists[0].get("id")
        
        tasks = agent.tasks.list_tasks(tasklist_id=tasklist_id)
        return {"tasks": tasks}
    except Exception as e:
        logger.error(f"Error listing tasks: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error listing tasks: {str(e)}"
        )

@app.post("/tasks")
async def create_task(task: TaskRequest, session_id: str = "default"):
    """Create a task."""
    agent = manager.get_agent(session_id)
    if not agent:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found"
        )
    
    try:
        # If no tasklist specified, get the default one
        tasklist_id = task.tasklist_id
        if not tasklist_id:
            tasklists = agent.tasks.list_tasklists()
            if not tasklists:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="No task lists found"
                )
            tasklist_id = tasklists[0].get("id")
        
        result = agent.tasks.create_task(
            tasklist_id=tasklist_id,
            title=task.title,
            notes=task.notes,
            due_date=task.due_date
        )
        return {"task": result}
    except Exception as e:
        logger.error(f"Error creating task: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating task: {str(e)}"
        )

# ----- WebSocket Endpoint -----

@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    """WebSocket endpoint for real-time chat with the agent."""
    success = await manager.connect(websocket, session_id)
    if not success:
        return
    
    try:
        while True:
            # Receive message from client
            data = await websocket.receive_text()
            logger.info(f"Received message from session {session_id}: {data}")
            
            try:
                # Process message with agent
                agent = manager.get_agent(session_id)
                if not agent:
                    await manager.send_message(session_id, {
                        "type": "error",
                        "content": "Agent not initialized"
                    })
                    continue
                
                # Parse the message
                try:
                    message_data = json.loads(data)
                    user_message = message_data.get("content", "")
                    message_id = message_data.get("message_id", str(uuid.uuid4()))
                except json.JSONDecodeError:
                    # If not valid JSON, treat the entire data as the message
                    user_message = data
                    message_id = str(uuid.uuid4())
                
                # Update session state
                manager.update_session_state(session_id)
                
                # Start typing indicator
                manager.start_typing_indicator(session_id, duration=3)
                
                # Process the message (this is where our agent takes time to respond)
                response = agent.process_input(user_message)
                
                # Send response back to client
                await manager.send_message(session_id, {
                    "type": "message",
                    "content": response,
                    "message_id": message_id,
                    "role": "assistant",
                    "timestamp": datetime.datetime.now().isoformat()
                })
            except Exception as e:
                logger.error(f"Error processing message: {e}")
                await manager.send_message(session_id, {
                    "type": "error",
                    "content": f"Error processing message: {str(e)}",
                    "message_id": str(uuid.uuid4())
                })
    except WebSocketDisconnect:
        logger.info(f"WebSocket client disconnected: {session_id}")
        manager.disconnect(session_id)
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        manager.disconnect(session_id)

# ----- Main Entry Point -----

def main():
    """Run the FastAPI application with Uvicorn."""
    # Check if running directly or being imported
    if __name__ == "__main__":
        # Get port from environment variable or use default
        port = int(os.getenv("PORT", "8000"))
        
        # Run the app with Uvicorn
        uvicorn.run(
            "api:app",
            host="0.0.0.0",
            port=port,
            reload=True,  # Enable hot reloading during development
            log_level="info"
        )

if __name__ == "__main__":
    main()
